Code Concatenation - Generated on 2025-02-24 04:52:47
================================================================================

File: next.config.js
--------------------

// next.config.js
module.exports = {
  reactStrictMode: true,
};


================================================================================

File: lib/prisma.js
-------------------

// lib/prisma.js
import { PrismaClient } from '@prisma/client';

let prisma;

if (process.env.NODE_ENV === 'production') {
  try {
    prisma = new PrismaClient();
  } catch (error) {
    console.error("Error creating PrismaClient in production:", error);
    throw error; // Re-throw to halt execution
  }
} else {
  // Ensure the PrismaClient is re-instantiated during hot-reloading
  // in development *BUT* only if it doesn't exist. This prevents
  // multiple PrismaClient instances.
  if (!globalThis.prisma) {
    try {
      globalThis.prisma = new PrismaClient();
    } catch (error) {
      console.error("Error creating PrismaClient in development:", error);
      throw error; // Re-throw to halt execution
    }
  }
  prisma = globalThis.prisma;
}

export default prisma;


================================================================================

File: pages/_app.js
-------------------

// pages/_app.js
import * as React from 'react';
import PropTypes from 'prop-types';
import Head from 'next/head';
import { SessionProvider } from "next-auth/react";
import { ThemeProvider, createTheme } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import dynamic from 'next/dynamic'; // Import dynamic

const theme = createTheme({
  palette: {
    mode: 'light'
    // Add additional theme customization here if needed
  },
});

const SWRConfig = dynamic(
  () => import('swr').then((mod) => mod.SWRConfig),
  { ssr: false }
);

export default function MyApp({ Component, pageProps: { session,...pageProps } }) {
  return (
    <SessionProvider session={session}>
      <Head>
        <title>Unified Workspace MVP</title>
        <meta name="viewport" content="initial-scale=1, width=device-width" />
      </Head>
      <ThemeProvider theme={theme}>
        <CssBaseline />
        <SWRConfig value={{
          fetcher: (url) => fetch(url).then(r => r.json()) // Customize the fetcher as needed
        }}>
          <Component {...pageProps} />
        </SWRConfig>
      </ThemeProvider>
    </SessionProvider>
  );
}

MyApp.propTypes = {
  Component: PropTypes.elementType.isRequired,
  pageProps: PropTypes.object.isRequired,
};


================================================================================

File: pages/index.js
--------------------

// pages/index.js
import { signIn, signOut, useSession } from "next-auth/react";
import { Button, Container, Typography } from "@mui/material";
import Link from "next/link";

export default function Home() {
  const { data: session } = useSession();
  
  if (session) {
    return (
      <Container sx={{ mt: 4 }}>
        <Typography variant="h4" gutterBottom>
          Welcome, {session.user.name}
        </Typography>
        <Button 
          variant="contained" 
          color="primary" 
          onClick={() => signOut()}
          sx={{ mr: 2 }}
        >
          Sign Out
        </Button>
        
        {/* NEW: Button or link to go to the chat page */}
        <Link href="/chat" passHref>
          <Button variant="contained" color="secondary">
            Go to Chat
          </Button>
        </Link>
      </Container>
    );
  }
  
  return (
    <Container sx={{ mt: 4 }}>
      <Typography variant="h4" gutterBottom>
        Unified Workspace MVP
      </Typography>
      <Button variant="contained" color="primary" onClick={() => signIn("google")}>
        Sign In with Google
      </Button>
    </Container>
  );
}


================================================================================

File: pages/tasks.js
--------------------

// pages/tasks.js
import React, { useState } from "react";
import useSWR from "swr";
import axios from "axios";
import { useSession } from "next-auth/react";
import {
  Container, Typography, Table, TableHead, TableBody, TableRow,
  TableCell, TextField, Select, MenuItem, IconButton, Paper
} from "@mui/material";
import DeleteIcon from '@mui/icons-material/Delete';
import SaveIcon from '@mui/icons-material/Save';

const fetcher = (url) => axios.get(url).then(res => res.data);
const statusOptions = ["YET_TO_BEGIN", "IN_PROGRESS", "DONE"];

export default function TaskTable() {
  const { data: session } = useSession();
  const { data, mutate } = useSWR(session? "/api/tasks": null, fetcher);
  const [editTaskId, setEditTaskId] = useState(null);
  const [editedTask, setEditedTask] = useState({});

  // Start editing a task by storing its current values
  const handleEdit = (task) => {
    setEditTaskId(task.id);
    setEditedTask({
      title: task.title,
      description: task.description,
      dueDate: task.dueDate? new Date(task.dueDate).toISOString().split("T"): "",
      status: task.status,
      priority: task.priority
    });
  };

  // Update task in the backend; note: dynamic reordering logic to adjust subsequent tasks
  const updateTask = async (taskId) => {
    try {
      await axios.put(`/api/tasks/${taskId}`, editedTask);
      setEditTaskId(null);
      mutate();
      // TODO: Add dynamic reordering logic here to slide priorities accordingly.
    } catch (error) {
      console.error("Error updating task:", error.response?.data || error.message);
    }
  };

  // Delete a task
  const deleteTask = async (taskId) => {
    try {
      await axios.delete(`/api/tasks/${taskId}`);
      mutate();
    } catch (error) {
      console.error("Error deleting task:", error.response?.data || error.message);
    }
  };

  const handleChange = (field, value) => {
    setEditedTask((prev) => ({...prev, [field]: value }));
  };

  if (!session) {
    return (
      <Container sx={{ mt: 4 }}>
        <Typography variant="h6">Please sign in to view tasks.</Typography>
      </Container>
    );
  }

  if (!data) {
    return <div>Loading...</div>; // Or a loading indicator component
  }

  return (
    <Container sx={{ mt: 4 }}>
      <Typography variant="h4" gutterBottom>Task Management</Typography>
      <Paper variant="outlined" sx={{ overflowX: "auto" }}>
        <Table>
          <TableHead>
            <TableRow>
              <TableCell>Title</TableCell>
              <TableCell>Description</TableCell>
              <TableCell>Due Date</TableCell>
              <TableCell>Status</TableCell>
              <TableCell>Priority</TableCell>
              <TableCell>Actions</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {data.tasks.map((task) => (
              <TableRow key={task.id}>
                <TableCell>
                  {editTaskId === task.id? (
                    <TextField
                      value={editedTask.title}
                      onChange={(e) => handleChange("title", e.target.value)}
                    />
                  ): (
                    task.title
                  )}
                </TableCell>
                <TableCell>
                  {editTaskId === task.id? (
                    <TextField
                      value={editedTask.description || ""}
                      onChange={(e) => handleChange("description", e.target.value)}
                    />
                  ): (
                    task.description
                  )}
                </TableCell>
                <TableCell>
                  {editTaskId === task.id? (
                    <TextField
                      type="date"
                      value={editedTask.dueDate}
                      onChange={(e) => handleChange("dueDate", e.target.value)}
                    />
                  ): (
                    task.dueDate? new Date(task.dueDate).toLocaleDateString(): ""
                  )}
                </TableCell>
                <TableCell>
                  {editTaskId === task.id? (
                    <Select
                      value={editedTask.status}
                      onChange={(e) => handleChange("status", e.target.value)}
                    >
                      {statusOptions.map((status) => (
                        <MenuItem key={status} value={status}>{status.replace("_", " ")}</MenuItem>
                      ))}
                    </Select>
                  ): (
                    task.status.replace("_", " ")
                  )}
                </TableCell>
                <TableCell>
                  {editTaskId === task.id? (
                    <TextField
                      type="number"
                      value={editedTask.priority}
                      onChange={(e) => handleChange("priority", parseInt(e.target.value, 10))}
                    />
                  ): (
                    task.priority
                  )}
                </TableCell>
                <TableCell>
                  {editTaskId === task.id? (
                    <IconButton onClick={() => updateTask(task.id)}>
                      <SaveIcon />
                    </IconButton>
                  ): (
                    <>
                      <IconButton onClick={() => handleEdit(task)}>
                        <SaveIcon />
                      </IconButton>
                      <IconButton onClick={() => deleteTask(task.id)}>
                        <DeleteIcon />
                      </IconButton>
                    </>
                  )}
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </Paper>
      <Typography variant="body2" color="textSecondary" sx={{ mt: 2 }}>
        * Adjusting the numeric priority will eventually reorder tasks automatically.
      </Typography>
    </Container>
  );
}


================================================================================

File: pages/chat.js
-------------------

// pages/chat.js
import React, { useState, useEffect, useRef } from "react";
import { useSession } from "next-auth/react";
import {
  Container,
  Grid,
  Box,
  TextField,
  Button,
  Typography,
  Paper
} from "@mui/material";
import axios from "axios";

// *** ADD THIS LINE ***
//axios.defaults.withCredentials = true; // Set globally for all axios requests

export default function Chat() {
  // ... (rest of your component code remains the same) ...
  const { data: session } = useSession();
  const [input, setInput] = useState("");
  // Initialize chatHistory as an empty array
  const [chatHistory, setChatHistory] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [isMounted, setIsMounted] = useState(false);
  const [tasks, setTasks] = useState([]); // <--- We'll store tasks here
  const messagesEndRef = useRef(null);

  useEffect(() => {
    // Fetch chat history on mount
    const fetchChatHistory = async () => {
      try {
        await ensureAuthenticated();
        const response = await axios.get("/api/chat/history"); // Removed: withCredentials: true
        const dbMessages = response.data.messages;

        // Map DB messages to the shape we need for display
        const mapped = dbMessages.map((msg) => {
          if (msg.role === "user") {
            return { role: "user", text: msg.messageText };
          } else {
            // role === "llm"
            // Use llmResponse if present, otherwise fallback
            return { role: "llm", text: msg.llmResponse || "" };
          }
        });

        setChatHistory(mapped);
      } catch (error) {
        console.error("Error fetching chat history:", error);
      }
    };

    // Fetch tasks on mount (so we see them in the right-hand panel)
    const fetchTasks = async () => {
      try {
        await ensureAuthenticated();
        const response = await axios.get("/api/tasks"); // Removed: withCredentials: true
        setTasks(response.data.tasks);
      } catch (error) {
        console.error("Error fetching tasks:", error);
      }
    };

    if (session) {
      fetchChatHistory();
      fetchTasks();
    }

    setIsMounted(true);
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [session]);

  // Quick helper to ensure we have a valid session
  const ensureAuthenticated = async () => {
    if (!session) {
      throw new Error("User not authenticated");
    }
  };

  if (!session) {
    return (
      <Container sx={{ mt: 4 }}>
        <Typography variant="h6">Please sign in to access the chat.</Typography>
      </Container>
    );
  }

  // Convert string priority to numeric
  const convertPriority = (priorityStr) => {
    switch (priorityStr?.toLowerCase()) {
      case "low":
        return 1;
      case "medium":
        return 2;
      case "high":
        return 3;
      default:
        return 2; // default to medium
    }
  };

  // Persist a message to the DB
  const saveMessageToDB = async (messageData) => {
    try {
      await axios.post("/api/chat/save", messageData); // Removed: withCredentials: true
    } catch (error) {
      console.error("Error saving message:", error.response?.data || error.message);
    }
  };

  // Create tasks in the DB from LLM tasks array
  const createTasksFromLLM = async (tasksFromLLM) => {
    for (const task of tasksFromLLM) {
      try {
        // If your LLM uses "inferred_due_date" instead of "due_date",
        // adjust accordingly:
        const dueDateValue = task.inferred_due_date || null;

        await axios.post("/api/tasks", {
          title: task.title,
          description: "", // or add a field if your LLM provides one
          dueDate: dueDateValue,
          status: "YET_TO_BEGIN",
          priority: convertPriority(task.priority),
          sourceMessageId: null
        });  // Removed: withCredentials: true
      } catch (error) {
        console.error("Error creating task:", error.response?.data || error.message);
      }
    }

    // Refresh tasks after creating them
    const updatedTasks = await axios.get("/api/tasks"); // Removed: withCredentials: true
    setTasks(updatedTasks.data.tasks);
  };

  const sendMessage = async () => {
    if (!input.trim()) return;

    // Add user message to local chat state
    const userMessage = { role: "user", text: input };
    setChatHistory((prev) => [...prev, userMessage]);

    // Save to DB
    await saveMessageToDB({ messageText: input, role: "user" });
    setIsLoading(true);

    // Build context from the last 15 messages
    const context = chatHistory.slice(-15).map((msg) => msg.text);

    try {
      // Call your LLM API
      const response = await axios.post("/api/llm", { message: input, context }); // Removed: withCredentials: true
      const llmData = response.data;

      // Only show the "acknowledgment" to the user
      const llmMessage = {
        role: "llm",
        text: llmData.acknowledgment,
        details: llmData
      };
      setChatHistory((prev) => [...prev, llmMessage]);

      // Save LLM response in DB
      await saveMessageToDB({
        messageText: input,   // Original user prompt
        role: "llm",
        llmResponse: llmData.acknowledgment,
        tags: llmData.tags
      });

      // If LLM returned tasks, create them in DB
      if (llmData.tasks && llmData.tasks.length > 0) {
        await createTasksFromLLM(llmData.tasks);
      }
    } catch (error) {
      console.error("LLM API error:", error.response?.data || error.message);
      const errorMessage = { role: "llm", text: "Error processing message" };
      setChatHistory((prev) => [...prev, errorMessage]);
      await saveMessageToDB({
        messageText: input,
        role: "llm",
        llmResponse: "Error processing message"
      });
    } finally {
      setInput("");
      setIsLoading(false);
    }
  };

  return (
    <Container sx={{ mt: 4 }}>
      <Grid container spacing={2}>
        {/* --- CHAT PANEL --- */}
        <Grid item xs={8}>
          <Typography variant="h4" gutterBottom>
            Chat Interface
          </Typography>
          <Paper variant="outlined" sx={{ height: "60vh", overflowY: "auto", p: 2 }}>
            {chatHistory.map((msg, index) => (
              <Box
                key={index}
                sx={{
                  display: "flex",
                  justifyContent: msg.role === "user" ? "flex-end" : "flex-start",
                  mb: 1
                }}
              >
                <Paper
                  sx={{
                    p: 1,
                    maxWidth: "80%",
                    backgroundColor: msg.role === "user" ? "#DCF8C6" : "#FFFFFF"
                  }}
                >
                  <Typography variant="body1">{msg.text}</Typography>
                </Paper>
              </Box>
            ))}
            <div ref={messagesEndRef} />
          </Paper>
          <Box sx={{ mt: 2, display: "flex" }}>
            <TextField
              fullWidth
              variant="outlined"
              placeholder="Type your message..."
              value={input}
              onChange={(e) => setInput(e.target.value)}
              onKeyDown={(e) => {
                if (e.key === "Enter") sendMessage();
              }}
            />
            <Button
              variant="contained"
              color="primary"
              onClick={sendMessage}
              disabled={isLoading}
              sx={{ ml: 2 }}
            >
              Send
            </Button>
          </Box>
        </Grid>

        {/* --- TASK LIST PANEL --- */}
        {isMounted && (
          <Grid item xs={4}>
            <Typography variant="h5" gutterBottom>
              Task List
            </Typography>
            <Paper variant="outlined" sx={{ height: "60vh", overflowY: "auto", p: 2 }}>
              {tasks.length === 0 ? (
                <Typography variant="body2" color="textSecondary">
                  (Tasks auto-created from LLM responses will appear here.)
                </Typography>
              ) : (
                tasks.map((task) => (
                  <Box key={task.id} sx={{ mb: 1 }}>
                    <Typography variant="body1" sx={{ fontWeight: "bold" }}>
                      {task.title}
                    </Typography>
                    <Typography variant="body2" color="textSecondary">
                      Due:{" "}
                      {task.dueDate
                        ? new Date(task.dueDate).toLocaleDateString()
                        : "No due date"}
                    </Typography>
                    <Typography variant="body2">
                      Priority: {task.priority}
                    </Typography>
                  </Box>
                ))
              )}
            </Paper>
          </Grid>
        )}
      </Grid>
    </Container>
  );
}


================================================================================

File: pages/api/llm.js
----------------------

// pages/api/llm.js
import { GoogleGenerativeAI } from "@google/generative-ai";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const { message, context } = req.body; // 'context' is an array of previous message texts

  if (!message) {
    return res.status(400).json({ error: "Message is required" });
  }

  try {
    const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
    const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });

    // Build prompt with extended instructions:
    let prompt = "";
    if (context && Array.isArray(context) && context.length > 0) {
      prompt += "Previous conversation (most recent 10-15 messages):\n";
      context.forEach((msg, index) => {
        prompt += `Message ${index + 1}: ${msg}\n`;
      });
      prompt += "\n";
    }
    prompt += "User: " + message + "\n\n";
    prompt +=
      "Instructions: " +
      "1. Acknowledge the user’s message succinctly. " +
      "2. Extract any actionable tasks from the message and list them as an array (each task with a title, inferred due date if any, and priority). " +
      "3. Identify if the message contains ambiguous references (e.g., unclear project or meeting context) and generate clarifying questions if needed. " +
      "4. Detect if there is a scope change in the conversation; if so, return a boolean 'scopeChange' as true and a 'scopeDemarcation' string that indicates the boundary (e.g. the message ID that needs retroactive tagging update). " +
      "5. Do not include internal tags or scope demarcation details in the user-facing acknowledgment. " +
      "6. Return a JSON object with keys: acknowledgment (string), tasks (array), clarifications (array), tags (object), scopeChange (boolean), scopeDemarcation (string). " +
      "7. If additional context is provided later, indicate which message IDs need retroactive tag updates (this may be part of the scopeDemarcation info). " +
      "8. Please return valid JSON without triple backticks or code fences.";

    // Send prompt to Gemini API
    const result = await model.generateContent(prompt);
    let responseText = await result.response.text();

    // Remove any triple-backtick fenced code blocks
    responseText = responseText.replace(/```[\s\S]*?```/g, "");

    // Attempt to parse the response as JSON
    let jsonResponse;
    try {
      jsonResponse = JSON.parse(responseText);
      // Ensure all required keys are present (fill defaults if missing)
      jsonResponse = {
        acknowledgment: jsonResponse.acknowledgment || "",
        tasks: Array.isArray(jsonResponse.tasks) ? jsonResponse.tasks : [],
        clarifications: Array.isArray(jsonResponse.clarifications)
          ? jsonResponse.clarifications
          : [],
        tags: typeof jsonResponse.tags === "object" ? jsonResponse.tags : {},
        scopeChange: !!jsonResponse.scopeChange,
        scopeDemarcation: jsonResponse.scopeDemarcation || ""
      };
    } catch (e) {
      // If parsing fails, fallback to plain acknowledgment and empty values
      jsonResponse = {
        acknowledgment: responseText,
        tasks: [],
        clarifications: [],
        tags: {},
        scopeChange: false,
        scopeDemarcation: ""
      };
    }

    res.status(200).json(jsonResponse);
  } catch (error) {
    console.error("Error processing LLM request:", error.message);
    res.status(500).json({ error: "LLM processing failed" });
  }
}


================================================================================

File: pages/api/gmail.js
------------------------

// pages/api/gmail.js
import { getSession } from "next-auth/react";
import axios from "axios";

export default async function handler(req, res) {
  const session = await getSession({ req });
  if (!session || !session.accessToken) {
    return res.status(401).json({ error: "Unauthorized" });
  }
  const accessToken = session.accessToken;
  
  try {
    // Calculate date 15 days ago in ISO format
    const fifteenDaysAgo = new Date(Date.now() - 15 * 24 * 60 * 60 * 1000).toISOString();
    
    // Fetch list of messages (up to 300) from the last 15 days
    const listResponse = await axios.get("https://gmail.googleapis.com/gmail/v1/users/me/messages", {
      headers: { Authorization: `Bearer ${accessToken}` },
      params: {
        q: `after:${fifteenDaysAgo}`,
        maxResults: 300
      }
    });
    
    const messages = listResponse.data.messages || [];
    // Fetch details for each message concurrently
    const detailedMessages = await Promise.all(messages.map(async (msg) => {
      const detailResponse = await axios.get(`https://gmail.googleapis.com/gmail/v1/users/me/messages/${msg.id}`, {
        headers: { Authorization: `Bearer ${accessToken}` },
        params: { format: "full" } // full format includes headers and body snippet
      });
      return detailResponse.data;
    }));
    
    // Return the fetched email details
    res.status(200).json({ emails: detailedMessages });
  } catch (error) {
    console.error("Error fetching Gmail messages:", error.response?.data || error.message);
    res.status(500).json({ error: "Failed to fetch emails" });
  }
}


================================================================================

File: pages/api/calendar.js
---------------------------

// pages/api/calendar.js
import { getSession } from "next-auth/react";
import axios from "axios";

export default async function handler(req, res) {
  const session = await getSession({ req });
  if (!session || !session.accessToken) {
    return res.status(401).json({ error: "Unauthorized" });
  }
  const accessToken = session.accessToken;
  
  try {
    // Define time range: from now to 4 weeks ahead
    const now = new Date().toISOString();
    const fourWeeksLater = new Date(Date.now() + 28 * 24 * 60 * 60 * 1000).toISOString();
    
    const calendarResponse = await axios.get("https://www.googleapis.com/calendar/v3/calendars/primary/events", {
      headers: { Authorization: `Bearer ${accessToken}` },
      params: {
        timeMin: now,
        timeMax: fourWeeksLater,
        singleEvents: true,
        orderBy: "startTime"
      }
    });
    
    const events = calendarResponse.data.items || [];
    res.status(200).json({ events });
  } catch (error) {
    console.error("Error fetching Calendar events:", error.response?.data || error.message);
    res.status(500).json({ error: "Failed to fetch calendar events" });
  }
}


================================================================================

File: pages/api/tasks/[id].js
-----------------------------

// pages/api/tasks/[id].js
import prisma from "../../../lib/prisma";
import { getSession } from "next-auth/react";

export default async function handler(req, res) {
  const { id } = req.query;
  const session = await getSession({ req });
  if (!session) {
    return res.status(401).json({ error: "Unauthorized" });
  }
  
  const userEmail = session.user.email;
  const user = await prisma.user.findUnique({ where: { email: userEmail } });
  if (!user) {
    return res.status(404).json({ error: "User not found" });
  }
  
  // Ensure that only tasks belonging to the authenticated user can be modified
  if (req.method === "PUT") {
    const { title, description, dueDate, status, priority } = req.body;
    const task = await prisma.task.findUnique({ where: { id: parseInt(id) } });
    if (!task || task.userId !== user.id) {
      return res.status(404).json({ error: "Task not found" });
    }
    // Update the task with new values
    const updatedTask = await prisma.task.update({
      where: { id: parseInt(id) },
      data: {
        title,
        description,
        dueDate: dueDate ? new Date(dueDate) : null,
        status,
        priority
      }
    });
    return res.status(200).json({ task: updatedTask });
  } else if (req.method === "DELETE") {
    const task = await prisma.task.findUnique({ where: { id: parseInt(id) } });
    if (!task || task.userId !== user.id) {
      return res.status(404).json({ error: "Task not found" });
    }
    await prisma.task.delete({ where: { id: parseInt(id) } });
    return res.status(200).json({ message: "Task deleted" });
  } else {
    return res.status(405).json({ error: "Method not allowed" });
  }
}


================================================================================

File: pages/api/tasks/index.js
------------------------------

// pages/api/tasks/index.js
import prisma from "../../../lib/prisma";
import { getSession } from "next-auth/react";

export default async function handler(req, res) {
  const session = await getSession({ req });
  if (!session) {
    return res.status(401).json({ error: "Unauthorized" });
  }

  const userEmail = session.user.email;
  const user = await prisma.user.findUnique({ where: { email: userEmail } });
  if (!user) {
    return res.status(404).json({ error: "User not found" });
  }

  if (req.method === "GET") {
    // Fetch tasks in ascending priority
    const tasks = await prisma.task.findMany({
      where: { userId: user.id },
      orderBy: { priority: "asc" }
    });
    return res.status(200).json({ tasks });
  } else if (req.method === "POST") {
    // Create a new task
    const { title, description, dueDate, status, priority, sourceMessageId } = req.body;
    const newTask = await prisma.task.create({
      data: {
        userId: user.id,
        title,
        description: description || "",
        dueDate: dueDate ? new Date(dueDate) : null,
        status: status || "YET_TO_BEGIN",
        priority: priority || 2, // default medium priority
        sourceMessageId: sourceMessageId || null
      }
    });
    return res.status(201).json({ task: newTask });
  } else {
    return res.status(405).json({ error: "Method not allowed" });
  }
}


================================================================================

File: pages/api/chat/save.js
----------------------------

// pages/api/chat/save.js
import prisma from "../../../lib/prisma";
import { getSession } from "next-auth/react";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const session = await getSession({ req });
    if (!session) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    const userEmail = session.user.email;
    const user = await prisma.user.findUnique({ where: { email: userEmail } });
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    const { messageText, role, llmResponse, tags } = req.body;
    if (!role) {
      return res.status(400).json({ error: "Role is required (e.g., 'user' or 'llm')" });
    }

    await prisma.chatMessage.create({
      data: {
        userId: user.id,
        role,
        messageText: messageText || "",
        llmResponse: llmResponse || null,
        tags: tags || {}
      }
    });

    res.status(200).json({ message: "Message saved" });
  } catch (error) {
    console.error("Error saving chat message:", error);
    res.status(500).json({ error: "Failed to save message" });
  }
}


================================================================================

File: pages/api/chat/history.js
-------------------------------

// pages/api/chat/history.js
import prisma from "../../../lib/prisma";
import { getSession } from "next-auth/react";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const session = await getSession({ req });
  if (!session) {
    return res.status(401).json({ error: "Unauthorized" });
  }

  try {
    const userEmail = session.user.email;
    const user = await prisma.user.findUnique({ where: { email: userEmail } });
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    const messages = await prisma.chatMessage.findMany({
      where: { userId: user.id },
      orderBy: { createdAt: "asc" }
    });

    res.status(200).json({ messages });
  } catch (error) {
    console.error("Error fetching chat history:", error);
    res.status(500).json({ error: "Failed to fetch chat history" });
  }
}


================================================================================

File: pages/api/auth/[...nextauth].js
-------------------------------------

// pages/api/auth/[...nextauth].js
import NextAuth from "next-auth";
import GoogleProvider from "next-auth/providers/google";
import { PrismaAdapter } from "@next-auth/prisma-adapter";
import prisma from "../../../lib/prisma"; // Corrected path

export default NextAuth({
  adapter: PrismaAdapter(prisma),
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET,
      authorization: {
        params: {
          scope:
            "openid email profile https://www.googleapis.com/auth/gmail.readonly https://www.googleapis.com/auth/calendar.readonly",
        },
      },
    }),
  ],
  secret: process.env.NEXTAUTH_SECRET,
  session: {
    strategy: "jwt",
  },
  callbacks: {
    async jwt({ token, account }) {
      if (account) {
        token.accessToken = account.access_token;
      }
      return token;
    },
    async session({ session, token }) {
      session.accessToken = token.accessToken;
      return session;
    },
  },
  //cookies: {  // ADDED: Cookie settings
   // sessionToken: {
     // name: "__Secure-next-auth.session-token",
      //options: {
       // httpOnly: true, // Recommended for security
        //sameSite: "none",
        //secure: true,
        //path: '/' // Ensure the cookie is accessible from all paths
     // }
    //}
//  }
});


================================================================================

